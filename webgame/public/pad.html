<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dataset Collector Pad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
  <style>
    :root{--bg:#0f1115;--bg2:#161a22;--fg:#e8eefc;--muted:#8fa0bf;--accent:#4cc3ff;--danger:#ff6b6b}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,sans-serif;overflow:hidden;touch-action:none;user-select:none}
    #wrap{display:grid;grid-template-rows:auto 1fr auto;height:100%;gap:8px}
    header,footer{padding:10px 12px;text-align:center;color:var(--muted)}
    header b{color:var(--fg)}
    .topbar{position:fixed;top:env(safe-area-inset-top,8px);left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);z-index:10;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .chip{background:#1b2332;border:1px solid #2b3344;border-radius:10px;padding:8px 10px;font-size:13px}
    .chip input,.chip select{background:transparent;border:none;color:#e8eefc;outline:none}
    .btn{background:#1b2332;color:#e8eefc;border:1px solid #2b3344;border-radius:10px;padding:8px 12px;font-size:13px}
    .btn:active{transform:scale(.98)}
    #controls{display:grid;grid-template-columns:1fr 1.2fr 1fr;gap:12px;padding:8px 12px 14px;align-items:center;height:100%}
    @media(max-width:820px){#controls{grid-template-columns:1fr}.padbox{max-width:95vw}}
    .stick{position:relative;width:100%;max-width:300px;aspect-ratio:1/1;margin:0 auto;border-radius:50%;
      background:radial-gradient(85% 85% at 50% 50%,#1c2330,#121722);border:2px solid #2b3344;box-shadow:inset 0 0 20px rgba(0,0,0,.35);touch-action:none}
    .knob{position:absolute;width:36%;aspect-ratio:1/1;border-radius:50%;left:32%;top:32%;
      background:linear-gradient(180deg,#2a3550,#1f2738);border:2px solid #39435a;box-shadow:0 6px 16px rgba(0,0,0,.5);transition:transform .04s linear}
    .label{text-align:center;margin-top:8px;font-size:14px;color:var(--muted)}
    .padbox{position:relative;width:100%;max-width:900px;aspect-ratio:16/10;margin:0 auto;background:linear-gradient(180deg,var(--bg2),#0f141d);
      border:2px solid #2b3344;border-radius:12px;box-shadow:inset 0 0 18px rgba(0,0,0,.35);overflow:hidden;touch-action:none;display:flex;align-items:center;justify-content:center;padding:10px}
    .padbox::after{content:"Draw symbol (one stroke). Lift, wait 2s → submit";position:absolute;inset:8px auto auto 8px;font-size:12px;color:#94a3bd}
    #draw{width:100%;height:100%;background:#ffffff;border-radius:8px;box-shadow:inset 0 0 6px rgba(0,0,0,.2);touch-action:none}
    #toast{position:fixed;left:50%;top:56px;transform:translateX(-50%);background:#1b2332;color:#cfe1ff;border:1px solid #2b3344;padding:8px 12px;border-radius:10px;z-index:9999;opacity:0;transition:opacity .15s}
    #fsBtn{position:fixed;right:12px;top:env(safe-area-inset-top,8px);z-index:10}
    /* small helper HUD for joystick values */
    #vals{position:fixed;right:12px;bottom:12px;z-index:10;background:rgba(17,22,30,.9);border:1px solid #2b3344;border-radius:10px;padding:8px 10px;font:12px ui-monospace,Menlo,Consolas}
  </style>

  <!-- If served from the same origin as server (Render), use the bundled socket.io -->
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
<button id="fsBtn" class="btn">Fullscreen</button>

<div class="topbar">
  <span class="chip">Room: <b id="roomLabel">demo</b></span>
  <span class="chip">User: <b id="userLabel">-</b></span>
  <span class="chip">Sample #: <b id="sampleIdx">1</b></span>
  <span class="chip">Label:
    <select id="label">
      <option value="triangle">triangle</option>
      <option value="square">square</option>
      <option value="circle">circle</option>
      <option value="star">star</option>
      <option value="custom">custom…</option>
    </select>
    <input id="labelCustom" placeholder="type label" style="display:none;width:110px">
  </span>
  <button class="btn" id="togglePublish">Publish: On</button>
  <button class="btn" id="clearBtn">Clear</button>
</div>

<div id="wrap">
  <header><b>Dataset Collector</b> · Draw and release to submit</header>

  <div id="controls">
    <div>
      <div class="stick" id="stickL"><div class="knob" id="knobL"></div></div>
      <div class="label">Move</div>
    </div>

    <div>
      <div class="padbox" id="padbox">
        <canvas id="draw"></canvas>
      </div>
      <div class="label">Drawing Pad</div>
    </div>

    <div>
      <div class="stick" id="stickR"><div class="knob" id="knobR"></div></div>
      <div class="label">Look</div>
    </div>
  </div>

  <footer><small>Original PNG + Grayscale PNG + Matrix saved per sample.</small></footer>
</div>

<div id="toast"></div>
<div id="vals">MOVE {x:0.00,y:0.00}<br>LOOK {x:0.00,y:0.00}</div>

<script>
  // ======== Fullscreen (mobile-safe) ========
  function isFullscreen(){ return !!(document.fullscreenElement || document.webkitFullscreenElement); }
  async function goFullscreen(){
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
    try{
      if (!isFullscreen() && req) await req.call(el);
      if (screen.orientation?.lock) { try{ await screen.orientation.lock("landscape"); }catch{} }
    }catch{}
  }
  document.getElementById("fsBtn").onclick = goFullscreen;
  document.addEventListener("gesturestart", e => e.preventDefault(), { passive:false });

  // ========= Config =========
  const INACTIVITY_MS = 2000;      // exactly 2 seconds after lift
  const MATRIX_SIZE   = 64;        // use 28 for MNIST-like

  // ========= Room & User =========
  const qs = new URLSearchParams(location.search);
  const ROOM = qs.get("room") || "demo";
  document.getElementById("roomLabel").textContent = ROOM;

  function getOrCreateUserId(){
    const key = "dataset_user_id_v1";
    let id = localStorage.getItem(key);
    if (!id){
      id = Math.random().toString(36).slice(2, 8); // 6-char code
      localStorage.setItem(key, id);
    }
    return id;
  }
  const USER_ID = getOrCreateUserId();
  document.getElementById("userLabel").textContent = USER_ID;

  // Label UI
  const labelSel = document.getElementById("label");
  const labelCustom = document.getElementById("labelCustom");
  let currentLabel = qs.get("label") || labelSel.value;
  labelSel.value = ["triangle","square","circle","star"].includes(currentLabel) ? currentLabel : "custom";
  labelCustom.style.display = (labelSel.value === "custom") ? "inline-block" : "none";
  if (labelSel.value === "custom") labelCustom.value = currentLabel;
  labelSel.onchange = () => { if (labelSel.value === "custom"){ labelCustom.style.display="inline-block"; labelCustom.focus(); } else { labelCustom.style.display="none"; currentLabel=labelSel.value; } };
  labelCustom.oninput = () => { currentLabel = labelCustom.value.trim() || "custom"; };

  // ========= Socket.IO (same-origin) =========
  // If serving from different origin, replace with: io("https://YOUR-DOMAIN");
  const socket = io();
  let publishOn = true;
  let myIndex = Number(localStorage.getItem("sampleIndex_"+ROOM+"_"+USER_ID) || "1");
  document.getElementById("sampleIdx").textContent = String(myIndex);
  document.getElementById("togglePublish").onclick = () => {
    publishOn = !publishOn;
    document.getElementById("togglePublish").textContent = "Publish: " + (publishOn ? "On" : "Off");
  };
  socket.on("connect", () => {
    socket.emit("join", { room: ROOM, userId: USER_ID }, (ack) => {
      if (!(ack?.ok)) toast(ack?.error || "Join failed", true);
    });
  });

  // ========= Fit canvas to screen & container =========
  const padbox = document.getElementById("padbox");
  const canvas = document.getElementById("draw");
  const ctx = canvas.getContext("2d", { willReadFrequently:true });
  let W=0, H=0;

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = padbox.getBoundingClientRect();
    const targetW = Math.floor(rect.width  * dpr);
    const targetH = Math.floor(rect.height * dpr);
    if (targetW === W && targetH === H) return;

    W = Math.max(1, targetW);
    H = Math.max(1, targetH);
    canvas.width = W; canvas.height = H;

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, W, H);
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 18 * dpr;
  }

  const ro = new ResizeObserver(() => fitCanvas());
  ro.observe(padbox);
  window.addEventListener("orientationchange", () => setTimeout(fitCanvas, 300), { passive:true });
  window.addEventListener("resize", () => setTimeout(fitCanvas, 100), { passive:true });
  fitCanvas();

  function toast(msg,bad){ const t=document.getElementById('toast'); t.textContent=msg; t.style.borderColor=bad?'#ff6b6b':'#2b3344'; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1200); }

  // ========= Drawing =========
  let drawing=false, lastX=0, lastY=0, idleTimer=null, hasInk=false;

  function stopIdle(){ if(idleTimer){ clearTimeout(idleTimer); idleTimer=null; } }
  function startIdle(){
    stopIdle();
    idleTimer=setTimeout(async ()=>{
      if (!hasInk) return;

      let cleared = false;
      const safety = setTimeout(() => {
        if (!cleared) {
          clearCanvas();
          hasInk = false;
          toast("Cleared ✓");
          cleared = true;
        }
      }, 1000);

      try {
        const ack = await submitCurrent();
        if (!cleared) {
          clearTimeout(safety);
          clearCanvas();
          hasInk = false;
          if (ack?.ok) {
            myIndex += 1;
            localStorage.setItem("sampleIndex_"+ROOM+"_"+USER_ID, String(myIndex));
            document.getElementById("sampleIdx").textContent = String(myIndex);
            toast("Saved & Cleared ✓");
          } else {
            toast(ack?.error || "Submit failed, cleared locally", true);
          }
          cleared = true;
        }
      } catch {
        if (!cleared) {
          clearTimeout(safety);
          clearCanvas();
          hasInk = false;
          toast("Error; cleared locally", true);
        }
      }
    }, INACTIVITY_MS);
  }

  function pt(e){ const t=e.touches?e.touches[0]:e; const r=canvas.getBoundingClientRect(); const dpr=Math.max(1,window.devicePixelRatio||1); return { x:(t.clientX-r.left)*dpr, y:(t.clientY-r.top)*dpr }; }
  function begin(e){ e.preventDefault(); stopIdle(); drawing=true; hasInk=true; const p=pt(e); lastX=p.x; lastY=p.y; }
  function move(e){ if(!drawing)return; const p=pt(e); ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(p.x,p.y); ctx.stroke(); lastX=p.x; lastY=p.y; }
  function end(){ if(!drawing)return; drawing=false; startIdle(); }
  function clearCanvas(){ fitCanvas(); }

  canvas.addEventListener("pointerdown", begin);
  canvas.addEventListener("pointermove", move);
  canvas.addEventListener("pointerup", end);
  canvas.addEventListener("pointercancel", end);
  canvas.addEventListener("pointerleave", ()=>drawing&&end());
  document.getElementById("clearBtn").onclick = clearCanvas;

  // ========= Joysticks (working MOVE/LOOK) =========
  const vals = document.getElementById("vals");
  function makeStick(stickEl, knobEl) {
    const rectState = { w:0, h:0, cx:0, cy:0, r:0 };
    const axes = { x:0, y:0 };
    let dragging = false;

    function cacheRect(){
      const r = stickEl.getBoundingClientRect();
      rectState.w = r.width; rectState.h = r.height;
      rectState.cx = r.left + r.width/2; rectState.cy = r.top + r.height/2;
      rectState.r = Math.min(r.width, r.height)*0.5*0.9;
    }
    function center(){ knobEl.style.left="32%"; knobEl.style.top="32%"; axes.x=0; axes.y=0; }

    function setKnob(px,py){
      const dx = px - rectState.cx, dy = py - rectState.cy;
      const mag = Math.hypot(dx,dy), cl = mag>rectState.r ? rectState.r/mag : 1;
      const cx = dx*cl, cy = dy*cl;
      const lx = (cx/rectState.w*100) + 50;
      const ly = (cy/rectState.h*100) + 50;
      knobEl.style.left = `calc(${lx}% - 18%)`;
      knobEl.style.top  = `calc(${ly}% - 18%)`;
      const dead=0.05;
      let nx = cx/rectState.r, ny = -cy/rectState.r;
      if (Math.abs(nx)<dead) nx=0;
      if (Math.abs(ny)<dead) ny=0;
      axes.x = +nx.toFixed(3); axes.y = +ny.toFixed(3);
    }

    stickEl.addEventListener("pointerdown", e => { cacheRect(); dragging=true; stickEl.setPointerCapture(e.pointerId); setKnob(e.clientX,e.clientY); });
    stickEl.addEventListener("pointermove", e => { if(dragging) setKnob(e.clientX,e.clientY); });
    function end(){ dragging=false; center(); }
    stickEl.addEventListener("pointerup", end);
    stickEl.addEventListener("pointercancel", end);
    stickEl.addEventListener("pointerleave", () => dragging && end());
    window.addEventListener("resize", cacheRect, { passive:true });
    center();
    return () => ({ x:axes.x, y:axes.y });
  }

  const getMove = makeStick(document.getElementById("stickL"), document.getElementById("knobL"));
  const getLook = makeStick(document.getElementById("stickR"), document.getElementById("knobR"));

  // Show values & (optionally) emit to server (server may ignore)
  let lastPadSent = 0;
  function tick(){
    const mv = getMove();
    const lk = getLook();
    vals.innerHTML = `MOVE {x:${mv.x.toFixed(2)}, y:${mv.y.toFixed(2)}}<br>LOOK {x:${lk.x.toFixed(2)}, y:${lk.y.toFixed(2)}}`;

    // throttle emits to ~20Hz
    const now = performance.now();
    if (publishOn && now - lastPadSent > 50){
      lastPadSent = now;
      // If your server handles "pad", it can consume this; otherwise harmless.
      socket.emit("pad", { room: ROOM, userId: USER_ID, axes: [mv.x, mv.y], look: [lk.x, lk.y], t: Date.now() });
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ========= Grayscale helpers =========
  function toGrayPNGDataURL(){
    const off = document.createElement("canvas");
    off.width = W; off.height = H;
    const octx = off.getContext("2d");
    octx.drawImage(canvas, 0, 0, W, H);

    const imgData = octx.getImageData(0, 0, W, H);
    const d = imgData.data;
    for (let i=0; i<d.length; i+=4){
      const gray = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      d[i] = d[i+1] = d[i+2] = gray;
    }
    octx.putImageData(imgData, 0, 0);
    return off.toDataURL("image/png");
  }
  function originalPNGDataURL(){ return canvas.toDataURL("image/png"); }

  function toGrayMatrix(size = MATRIX_SIZE){
    const off = document.createElement("canvas");
    off.width = size; off.height = size;
    const octx = off.getContext("2d", { willReadFrequently:true });
    octx.fillStyle = "#fff"; octx.fillRect(0,0,size,size);
    octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality = "high";
    octx.drawImage(canvas, 0, 0, W, H, 0, 0, size, size);

    const img = octx.getImageData(0, 0, size, size).data;
    const matrix = [];
    for (let y=0; y<size; y++){
      const row = [];
      for (let x=0; x<size; x++){
        const i = (y*size + x) * 4;
        const r = img[i], g = img[i+1], b = img[i+2];
        const gray = Math.round(0.299*r + 0.587*g + 0.114*b);
        row.push(gray);
      }
      matrix.push(row);
    }
    return matrix;
  }

  // ========= Submit (original + gray + matrix) =========
  function submitCurrent(){
    return new Promise((resolve) => {
      if (!publishOn) return resolve({ ok:true, skipped:true });

      const label = (labelSel.value==="custom") ? (labelCustom.value.trim()||"custom") : labelSel.value;
      const payload = {
        room: ROOM,
        userId: USER_ID,
        index: myIndex,
        label,
        ts: Date.now(),
        size: { w: W, h: H },
        imageOriginal: originalPNGDataURL(),
        imageGray: toGrayPNGDataURL(),
        matrixSize: MATRIX_SIZE,
        matrix: toGrayMatrix(MATRIX_SIZE)
      };

      socket.emit("sample", payload, (ack) => {
        resolve(ack || { ok:false, error:"No ack" });
      });
    });
  }
</script>
</body>
</html>
