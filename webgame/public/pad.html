<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Game Pad + Symbol Matrix (Socket.IO)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
  <meta name="theme-color" content="#000000">
  <style>
    :root{--bg:#0f1115;--bg2:#161a22;--fg:#e8eefc;--muted:#8fa0bf;--accent:#4cc3ff;--danger:#ff6b6b}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden;touch-action:none;user-select:none}
    #wrap{display:grid;grid-template-rows:auto 1fr auto;height:100%;gap:8px}
    header,footer{padding:10px 12px;text-align:center;color:var(--muted)}
    header b{color:var(--fg)}

    .topbar{position:fixed;top:env(safe-area-inset-top,8px);left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);z-index:10;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .chip{background:#1b2332;border:1px solid #2b3344;border-radius:10px;padding:8px 10px;font-size:13px}
    .chip input,.chip select{background:transparent;border:none;color:#e8eefc;outline:none}
    .btn{background:#1b2332;color:#e8eefc;border:1px solid #2b3344;border-radius:10px;padding:8px 12px;font-size:13px}
    .btn:active{transform:scale(.98)}

    #controls{display:grid;grid-template-columns:1fr 1.2fr 1fr;gap:12px;padding:8px 12px 14px;align-items:center;height:100%}
    @media(max-width:820px){#controls{grid-template-columns:1fr}.padbox{max-width:95vw}}

    .stick{position:relative;width:100%;max-width:300px;aspect-ratio:1/1;margin:0 auto;border-radius:50%;
      background:radial-gradient(85% 85% at 50% 50%,#1c2330,#121722);border:2px solid #2b3344;box-shadow:inset 0 0 20px rgba(0,0,0,.35);touch-action:none}
    .knob{position:absolute;width:36%;aspect-ratio:1/1;border-radius:50%;left:32%;top:32%;
      background:linear-gradient(180deg,#2a3550,#1f2738);border:2px solid #39435a;box-shadow:0 6px 16px rgba(0,0,0,.5);transition:transform .04s linear}
    .label{text-align:center;margin-top:8px;font-size:14px;color:var(--muted)}

    .padbox{position:relative;width:100%;max-width:900px;aspect-ratio:16/10;margin:0 auto;background:linear-gradient(180deg,var(--bg2),#0f141d);
      border:2px solid #2b3344;border-radius:12px;box-shadow:inset 0 0 18px rgba(0,0,0,.35);overflow:hidden;display:flex;align-items:center;justify-content:center;padding:10px}
    .padbox::after{content:"Draw symbol (one stroke). Lift, wait 2s → submit";position:absolute;inset:8px auto auto 8px;font-size:12px;color:#94a3bd;pointer-events:none}

    /* Fixed intrinsic pixels for consistent dataset; CSS scales this visually */
    #draw{width:100%;height:100%;background:#ffffff;border-radius:8px;box-shadow:inset 0 0 6px rgba(0,0,0,.2);touch-action:none;image-rendering:pixelated}

    #hud{position:fixed;left:12px;bottom:12px;z-index:10;width:min(92vw,440px);background:rgba(17,22,30,.9);border:1px solid #2b3344;border-radius:12px;
      padding:10px 12px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.25;display:none;white-space:pre;overflow:auto;max-height:52vh}

    #matrixWrap{position:fixed;left:12px;bottom:12px;z-index:11;width:min(92vw,520px);background:rgba(17,22,30,.92);border:1px solid #2b3344;border-radius:12px;
      padding:10px 12px;display:none;max-height:55vh;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.25}
    #matrixWrap header{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;color:#cfe1ff}
    #matrix{white-space:pre}

    #fsBtn{position:fixed;right:12px;top:env(safe-area-inset-top,8px);z-index:10}
    #vals{position:fixed;right:12px;bottom:12px;z-index:10;background:rgba(17,22,30,.9);border:1px solid #2b3344;border-radius:10px;padding:8px 10px;font:12px ui-monospace,Menlo,Consolas}
    #toast{position:fixed;left:50%;top:56px;transform:translateX(-50%);background:#1b2332;color:#cfe1ff;border:1px solid #2b3344;padding:8px 12px;border-radius:10px;z-index:9999;opacity:0;transition:opacity .15s}
  </style>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
</head>
<body>
<button id="fsBtn" class="btn">Fullscreen</button>

<div class="topbar">
  <span class="chip">Room: <b id="roomLabel">demo</b></span>
  <span class="chip">User: <b id="userLabel">-</b></span>
  <span class="chip">Sample #: <b id="sampleIdx">1</b></span>
  <span class="chip">Label:
    <select id="label">
      <option value="triangle">triangle</option>
      <option value="square">square</option>
      <option value="circle">circle</option>
      <option value="star">star</option>
      <option value="custom">custom…</option>
    </select>
    <input id="labelCustom" placeholder="type label" style="display:none;width:110px">
  </span>
  <button class="btn" id="togglePublish">Publish: On</button>
  <button class="btn" id="clearBtn">Clear</button>
  <button class="btn" id="toggleMatrixBtn">Show Matrix</button>
  <button class="btn" id="hudToggle">HUD: Off</button>
</div>

<div id="wrap">
  <header>
    <b>Game Pad + Symbol Matrix</b> · Fixed canvas for consistent dataset
  </header>

  <div id="controls">
    <div>
      <div class="stick" id="stickL"><div class="knob" id="knobL"></div></div>
      <div class="label">Move</div>
    </div>

    <div>
      <div class="padbox" id="padbox">
        <canvas id="draw"></canvas>
      </div>
      <div class="label">Draw symbol (one stroke)</div>
    </div>

    <div>
      <div class="stick" id="stickR"><div class="knob" id="knobR"></div></div>
      <div class="label">Look</div>
    </div>
  </div>

  <footer>
    <small>Matrix is grayscale 0..255 (white→black). One payload per symbol. Canvas clears right after submit.</small>
  </footer>
</div>

<pre id="hud"></pre>
<div id="matrixWrap">
  <header>
    <div>Grayscale Matrix Output</div>
    <div id="meta" style="font-size:12px;opacity:.8;"></div>
  </header>
  <div id="matrix"></div>
</div>
<div id="vals">MOVE {x:0.00,y:0.00}<br>LOOK {x:0.00,y:0.00}</div>
<div id="toast"></div>

<script>
  // ======= Config (SET THIS to your server URL) =======
  const SOCKET_SERVER_URL = "https://gamepad-be1f.onrender.com"; // e.g., your Render/ngrok base URL
  const MATRIX_SIZE   = 64;        // 28 for MNIST-like
  const PEN_WIDTH_PX  = 18;
  const PEN_COLOR     = "#000000";
  const INACTIVITY_MS = 2000;
  const CANVAS_W = 512, CANVAS_H = 320; // fixed pixels everywhere

  // ======= Fullscreen =======
  function isFS(){ return !!(document.fullscreenElement || document.webkitFullscreenElement); }
  async function goFS(){
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
    try{
      if (!isFS() && req) await req.call(el);
      if (screen.orientation?.lock) { try{ await screen.orientation.lock("landscape"); }catch{} }
    }catch{}
  }
  document.getElementById("fsBtn").addEventListener("click", goFS);
  document.addEventListener("gesturestart", e => e.preventDefault(), { passive:false });

  // ======= Room & User =======
  const qs = new URLSearchParams(location.search);
  const ROOM = qs.get("room") || "demo";
  document.getElementById("roomLabel").textContent = ROOM;

  function getOrCreateUserId(){
    const key = "dataset_user_id_v1";
    let id = localStorage.getItem(key);
    if (!id){ id = Math.random().toString(36).slice(2,8); localStorage.setItem(key,id); }
    return id;
  }
  const USER_ID = getOrCreateUserId();
  document.getElementById("userLabel").textContent = USER_ID;

  const labelSel = document.getElementById("label");
  const labelCustom = document.getElementById("labelCustom");
  let currentLabel = qs.get("label") || labelSel.value;
  labelSel.value = ["triangle","square","circle","star"].includes(currentLabel) ? currentLabel : "custom";
  labelCustom.style.display = (labelSel.value === "custom") ? "inline-block" : "none";
  if (labelSel.value === "custom") labelCustom.value = currentLabel;
  labelSel.onchange = () => { if (labelSel.value === "custom"){ labelCustom.style.display="inline-block"; labelCustom.focus(); } else { labelCustom.style.display="none"; currentLabel=labelSel.value; } };
  labelCustom.oninput = () => { currentLabel = labelCustom.value.trim() || "custom"; };

  // ======= Socket.IO =======
  const socket = io(SOCKET_SERVER_URL, { transports:["websocket"], forceNew:true, path: "/socket.io" });
  let publishOn = true;
  let myIndex = Number(localStorage.getItem("sampleIndex_"+ROOM+"_"+USER_ID) || "1");
  document.getElementById("sampleIdx").textContent = String(myIndex);
  document.getElementById("togglePublish").onclick = () => {
    publishOn = !publishOn;
    document.getElementById("togglePublish").textContent = "Publish: " + (publishOn ? "On" : "Off");
  };

  socket.on("connect", () => {
    socket.emit("join", { room: ROOM, userId: USER_ID }, (ack) => {
      if (ack?.ok) toast(`Joined ${ROOM} (${ack.count}/10)`); else toast(ack?.error || "Room full", true);
    });
  });

  // ======= Joysticks =======
  function makeStick(stickEl, knobEl) {
    const rect = { w:0, h:0, cx:0, cy:0, r:0 };
    const axes = { x:0, y:0 };
    let dragging = false;

    function cache(){ const r=stickEl.getBoundingClientRect(); rect.w=r.width; rect.h=r.height; rect.cx=r.left+r.width/2; rect.cy=r.top+r.height/2; rect.r=Math.min(r.width,r.height)*0.5*0.9; }
    function center(){ knobEl.style.left="32%"; knobEl.style.top="32%"; axes.x=0; axes.y=0; }
    function set(px,py){
      const dx=px-rect.cx, dy=py-rect.cy; const mag=Math.hypot(dx,dy), cl=mag>rect.r?rect.r/mag:1;
      const cx=dx*cl, cy=dy*cl; const lx=(cx/rect.w*100)+50; const ly=(cy/rect.h*100)+50;
      knobEl.style.left=`calc(${lx}% - 18%)`; knobEl.style.top=`calc(${ly}% - 18%)`;
      const dead=0.05; let nx=cx/rect.r, ny=-cy/rect.r; if(Math.abs(nx)<dead)nx=0; if(Math.abs(ny)<dead)ny=0; axes.x=+nx.toFixed(3); axes.y=+ny.toFixed(3);
    }
    stickEl.addEventListener("pointerdown", e=>{ cache(); dragging=true; stickEl.setPointerCapture(e.pointerId); set(e.clientX,e.clientY); });
    stickEl.addEventListener("pointermove", e=>{ if(dragging) set(e.clientX,e.clientY); });
    function end(){ dragging=false; center(); }
    stickEl.addEventListener("pointerup", end); stickEl.addEventListener("pointercancel", end); stickEl.addEventListener("pointerleave", ()=>dragging&&end());
    window.addEventListener("resize", cache, { passive:true });
    center(); return ()=>({x:axes.x,y:axes.y});
  }
  const getMove = makeStick(document.getElementById("stickL"), document.getElementById("knobL"));
  const getLook = makeStick(document.getElementById("stickR"), document.getElementById("knobR"));

  // live HUD + (optional) stream to server as pad state
  const vals = document.getElementById("vals");
  let lastSent = 0;
  let hudOn = false;
  document.getElementById("hudToggle").onclick = () => {
    hudOn = !hudOn; document.getElementById("hud").style.display = hudOn ? "block" : "none";
    document.getElementById("hudToggle").textContent = "HUD: " + (hudOn ? "On" : "Off");
  };
  function hudTick(){
    const mv = getMove(), lk = getLook();
    vals.innerHTML = `MOVE {x:${mv.x.toFixed(2)}, y:${mv.y.toFixed(2)}}<br>LOOK {x:${lk.x.toFixed(2)}, y:${lk.y.toFixed(2)}}`;
    const now = performance.now();
    if (publishOn && now - lastSent > 33){
      lastSent = now;
      socket.emit("pad", { room: ROOM, userId: USER_ID, axes:[mv.x,mv.y], look:[lk.x,lk.y], t:Date.now() });
    }
    if (hudOn){
      document.getElementById("hud").textContent =
`<Gamepad Output>
MOVE  : { x: ${mv.x.toFixed(3)}, y: ${mv.y.toFixed(3)} }
LOOK  : { x: ${lk.x.toFixed(3)}, y: ${lk.y.toFixed(3)} }`;
    }
    requestAnimationFrame(hudTick);
  }
  requestAnimationFrame(hudTick);

  // ======= Drawing (fixed intrinsic pixels) =======
  const canvas = document.getElementById("draw");
  const ctx = canvas.getContext("2d", { willReadFrequently:true });
  canvas.width = CANVAS_W; canvas.height = CANVAS_H;

  function resetBrush(){
    ctx.fillStyle = "#ffffff"; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.lineJoin = "round"; ctx.lineCap = "round";
    ctx.strokeStyle = PEN_COLOR; ctx.lineWidth = PEN_WIDTH_PX;
  }
  resetBrush();

  function clearCanvasOnly(){
    ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.restore();
    resetBrush();
  }

  let drawing=false, lastX=0, lastY=0, idleTimer=null, hasInk=false;
  function stopIdle(){ if(idleTimer){ clearTimeout(idleTimer); idleTimer=null; } }
  function startIdle(){
    stopIdle();
    idleTimer = setTimeout(()=>{ if(hasInk){ submitNow(); } }, INACTIVITY_MS);
  }

  function pt(e){
    const t=e.touches?e.touches[0]:e, r=canvas.getBoundingClientRect();
    const sx=canvas.width/r.width, sy=canvas.height/r.height;
    return { x:(t.clientX-r.left)*sx, y:(t.clientY-r.top)*sy };
  }
  function begin(e){ e.preventDefault(); stopIdle(); drawing=true; hasInk=true; const p=pt(e); lastX=p.x; lastY=p.y; }
  function move (e){ if(!drawing) return; const p=pt(e); ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(p.x,p.y); ctx.stroke(); lastX=p.x; lastY=p.y; }
  function end  (){ if(!drawing) return; drawing=false; startIdle(); }

  canvas.addEventListener("pointerdown", begin);
  canvas.addEventListener("pointermove", move);
  canvas.addEventListener("pointerup", end);
  canvas.addEventListener("pointercancel", end);
  canvas.addEventListener("pointerleave", ()=>drawing&&end());
  document.getElementById("clearBtn").onclick = () => { stopIdle(); clearCanvasOnly(); hasInk=false; };

  // ======= Matrix + submit =======
  const matrixWrap = document.getElementById("matrixWrap");
  const matrixOut  = document.getElementById("matrix");
  const metaEl     = document.getElementById("meta");
  document.getElementById("toggleMatrixBtn").onclick = () => {
    matrixWrap.style.display = (matrixWrap.style.display === "none" || matrixWrap.style.display==="") ? "block" : "none";
  };

  function rasterizeToMatrix(){
    const off=document.createElement("canvas"); off.width=MATRIX_SIZE; off.height=MATRIX_SIZE;
    const octx=off.getContext("2d", { willReadFrequently:true });
    octx.fillStyle="#ffffff"; octx.fillRect(0,0,MATRIX_SIZE,MATRIX_SIZE);
    octx.imageSmoothingEnabled=true; octx.imageSmoothingQuality="high";
    octx.drawImage(canvas,0,0,canvas.width,canvas.height,0,0,MATRIX_SIZE,MATRIX_SIZE);
    const img=octx.getImageData(0,0,MATRIX_SIZE,MATRIX_SIZE).data;
    const mat=[];
    for(let y=0;y<MATRIX_SIZE;y++){
      const row=[];
      for(let x=0;x<MATRIX_SIZE;x++){
        const i=(y*MATRIX_SIZE+x)*4, r=img[i], g=img[i+1], b=img[i+2];
        row.push(Math.round(0.299*r+0.587*g+0.114*b));
      }
      mat.push(row);
    }
    return mat;
  }
  function showMatrix(mat){
    matrixWrap.style.display="block";
    metaEl.textContent=`size=${mat.length}×${mat[0].length} • values=0..255 (white→black)`;
    matrixOut.textContent=JSON.stringify(mat);
  }
  function canvasPNG(){ return canvas.toDataURL("image/png"); }

  function submitNow(){
    const label = (labelSel.value==="custom") ? (labelCustom.value.trim()||"custom") : labelSel.value;
    const matrix = rasterizeToMatrix();
    showMatrix(matrix);

    if (publishOn){
      socket.emit("sample", {
        room: ROOM,
        userId: USER_ID,
        index: myIndex,
        label,
        ts: Date.now(),
        size: { w: canvas.width, h: canvas.height },
        matrixSize: MATRIX_SIZE,
        matrix,                          // <-- matrix column goes to CSV (as JSON string)
        image: canvasPNG()               // <-- PNG saved to disk
      }, (ack)=>{
        if (ack?.ok){
          myIndex += 1; localStorage.setItem("sampleIndex_"+ROOM+"_"+USER_ID, String(myIndex));
          document.getElementById("sampleIdx").textContent = String(myIndex);
          toast("Captured ✓");
        } else {
          toast(ack?.error || "Submit failed", true);
        }
      });
    }
    clearCanvasOnly(); hasInk=false; // always clear immediately
  }

  function toast(msg,bad){ const t=document.getElementById('toast'); t.textContent=msg; t.style.borderColor=bad?'#ff6b6b':'#2b3344'; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1100); }
</script>
</body>
</html>
